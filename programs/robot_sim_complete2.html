<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>Modular Robot Nav Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CSS Reset & Custom Styles */
        body { background-color: #050505; color: #cbd5e1; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { touch-action: none; cursor: crosshair; image-rendering: pixelated; }
        
        /* Panel Styles */
        .panel { @apply mb-4 border-b border-slate-800 pb-4; }
        .lbl { @apply text-[10px] uppercase font-bold mb-1 block tracking-wider; }
        .btn { @apply px-3 py-1 text-xs border rounded transition hover:bg-opacity-80 active:scale-95; }
        .btn-tool { @apply bg-slate-800 border-slate-700 text-slate-300 hover:bg-slate-700; }
        .btn-active { @apply bg-sky-900 border-sky-500 text-sky-200; }
        
        /* Slider Custom */
        input[type=range] { @apply w-full h-1 bg-slate-800 rounded appearance-none cursor-pointer; }
        input[type=range]::-webkit-slider-thumb { @apply w-3 h-3 bg-sky-500 rounded-full appearance-none; }
    </style>
</head>
<body class="h-screen flex flex-col">

    <header class="h-12 bg-slate-900 border-b border-slate-800 flex justify-between items-center px-4">
        <h1 class="text-sm font-bold text-sky-400 font-mono">NAV-STACK <span class="text-slate-600">v3.0</span></h1>
        <div class="flex gap-2">
            <button id="btn-run" onclick="SIM_CORE.toggle()" class="btn bg-emerald-600 border-emerald-500 text-white font-bold">â–¶ START SIM</button>
            <button onclick="MAP.reset()" class="btn bg-rose-900/30 border-rose-800 text-rose-400">ðŸ—‘ RESET MAP</button>
        </div>
    </header>

    <div class="flex-grow flex overflow-hidden">
        
        <aside class="w-72 bg-slate-900 border-r border-slate-800 p-4 overflow-y-auto flex flex-col gap-2 z-10 shadow-xl">
            
            <div class="panel">
                <label class="lbl text-emerald-500">1. Global Planner (Map)</label>
                <div class="grid grid-cols-2 gap-1 mb-2">
                    <button onclick="MAP.setMode('wall')" id="t-wall" class="btn btn-tool">ðŸ§± Wall</button>
                    <button onclick="MAP.setMode('eraser')" id="t-eraser" class="btn btn-tool">ðŸ§½ Erase</button>
                    <button onclick="MAP.setMode('start')" id="t-start" class="btn btn-tool text-emerald-400">ðŸŸ¢ Start</button>
                    <button onclick="MAP.setMode('goal')" id="t-goal" class="btn btn-tool text-rose-400">ðŸš© Goal</button>
                </div>
                <select id="global-algo" class="w-full bg-slate-950 text-xs p-1 border border-slate-700 text-slate-300 rounded">
                    <option value="astar">A* (A-Star Algorithm)</option>
                    <option value="dijkstra">Dijkstra Algorithm</option>
                    <option value="none">None (Manual Path)</option>
                </select>
            </div>

            <div class="panel">
                <label class="lbl text-amber-500">2. Local & Control</label>
                <select id="control-mode" class="w-full bg-slate-950 text-xs p-1 border border-slate-700 text-slate-300 rounded mb-3" onchange="UI.updatePanel()">
                    <option value="pid">PID Path Follower (Controller)</option>
                    <option value="apf">Artificial Potential Field (Planner)</option>
                </select>

                <div id="p-pid" class="space-y-3">
                    <div>
                        <div class="flex justify-between text-[10px]"><span>Steering Gain (Kp)</span> <span id="v-kp" class="text-sky-400">3.0</span></div>
                        <input type="range" min="0" max="10" step="0.1" value="3.0" oninput="Params.pid.kp=this.value; UI.val('v-kp', this.value)">
                    </div>
                    <div>
                        <div class="flex justify-between text-[10px]"><span>Look Ahead Dist</span> <span id="v-ld" class="text-sky-400">40</span></div>
                        <input type="range" min="10" max="100" step="5" value="40" oninput="Params.pid.lookAhead=parseInt(this.value); UI.val('v-ld', this.value)">
                    </div>
                </div>

                <div id="p-apf" class="space-y-3 hidden">
                    <div>
                        <div class="flex justify-between text-[10px]"><span>Attraction (Goal)</span> <span id="v-att" class="text-emerald-400">2.0</span></div>
                        <input type="range" min="0.1" max="10" step="0.1" value="2.0" oninput="Params.apf.k_att=this.value; UI.val('v-att', this.value)">
                    </div>
                    <div>
                        <div class="flex justify-between text-[10px]"><span>Repulsion (Wall)</span> <span id="v-rep" class="text-rose-400">200</span></div>
                        <input type="range" min="0" max="500" step="10" value="200" oninput="Params.apf.k_rep=this.value; UI.val('v-rep', this.value)">
                    </div>
                </div>
            </div>

            <div class="panel border-none">
                <label class="lbl text-purple-500">3. Robot Specs</label>
                <div>
                    <div class="flex justify-between text-[10px]"><span>Max Speed</span> <span id="v-spd" class="text-purple-400">4.0</span></div>
                    <input type="range" min="1" max="10" step="0.5" value="4.0" oninput="Params.robot.maxSpeed=parseFloat(this.value); UI.val('v-spd', this.value)">
                </div>
            </div>
			
			<div class="panel">
                <label class="lbl text-purple-500">3. Robot Specs</label>
                <div>
                    <div class="flex justify-between text-[10px]"><span>Max Speed</span> <span id="v-spd" class="text-purple-400">0.5 m/s</span></div>
                    <input type="range" min="0.1" max="2.0" step="0.1" value="0.5" oninput="Params.robot.maxSpeed=parseFloat(this.value); UI.val('v-spd', this.value + ' m/s')">
                </div>
            </div>

            <div class="panel border-none">
                <label class="lbl text-slate-400">4. Sim Speed</label>
                <div>
                    <div class="flex justify-between text-[10px]"><span>Time Scale</span> <span id="v-time" class="text-slate-300">1.0x</span></div>
                    <input type="range" min="0.1" max="5.0" step="0.1" value="1.0" oninput="State.timeScale=parseFloat(this.value); UI.val('v-time', this.value + 'x')">
                </div>
            </div>

            <div class="mt-auto bg-black/50 p-2 rounded border border-slate-800 font-mono text-[9px] text-slate-500">
                <div id="debug-state">State: IDLE</div>
                <div id="debug-pos">Pos: 0, 0</div>
            </div>
        </aside>

        <main class="flex-grow bg-[#0a0a0a] relative flex items-center justify-center">
            <canvas id="simCanvas" class="shadow-2xl border border-slate-800 bg-black"></canvas>
            <div class="absolute top-4 left-4 pointer-events-none text-[10px] text-slate-600">
                Grid: 25px | 60 FPS
            </div>
        </main>
    </div>

<script>
    /**
     * GLOBAL STATE & CONFIGURATION
     * Objek ini adalah "Single Source of Truth" untuk seluruh modul.
     */
    
    // 1. Parameter Tuning (Bisa diubah real-time via Slider)
    const Params = {
        // Pixel per Meter (50px = 1 meter)
        ppm: 50, 
        
        pid: { kp: 3.0, lookAhead: 40 }, // lookAhead dalam pixel
        apf: { k_att: 2.0, k_rep: 200, distLimit: 60 },
        robot: { 
            maxSpeed: 0.5, // Default 0.5 m/s
            radius: 9 
        }
    };

    // [UPDATE] State Simulasi
    const State = {
        running: false,
        dt: 0.016,
        timeScale: 1.0, // [BARU] Faktor kecepatan simulasi
        
        map: {
            cols: 40, rows: 25, size: 25,
            grid: [], width: 0, height: 0
        },
        obj: {
            start: { x: 2, y: 2 },
            goal:  { x: 35, y: 20 },
            robot: { x: 0, y: 0, th: 0, v: 0, w: 0 }
        },
        path: [],
        trail: [] // [BARU] Array untuk menyimpan jejak lintasan asli
    };

    // 3. UI Helpers
    const UI = {
        val: (id, v) => document.getElementById(id).innerText = v,
        log: (msg) => document.getElementById('debug-state').innerText = msg,
        
        updatePanel: function() {
            const mode = document.getElementById('control-mode').value;
            // Toggle tampilan parameter sesuai mode
            document.getElementById('p-pid').style.display = (mode === 'pid') ? 'block' : 'none';
            document.getElementById('p-apf').style.display = (mode === 'apf') ? 'block' : 'none';
        }
    };

    // Placeholder Modules (Akan diisi di bagian selanjutnya)
    //const MAP = { reset:()=>{}, setMode:()=>{} };
    //const SIM_CORE = { toggle:()=>{} };
	
	/** ==========================================
     * BAGIAN 2: MAP ENGINE & GLOBAL PLANNER
     * ==========================================
     */

    // --- MAP ENGINE (Menangani Tampilan & Input Mouse) ---
    const MAP = {
        mode: 'wall', // Mode aktif saat ini (wall/eraser/start/goal)
        isDown: false, // Status klik mouse

        init: function() {
            const cvs = document.getElementById('simCanvas');
            const m = State.map;
            
            // Set ukuran canvas sesuai jumlah grid
            cvs.width = m.cols * m.size;
            cvs.height = m.rows * m.size;
            m.width = cvs.width;
            m.height = cvs.height;

            // Buat Array Grid Kosong
            this.reset();

            // Event Listeners Mouse
            cvs.addEventListener('mousedown', e => { this.isDown=true; this.input(e); });
            cvs.addEventListener('mousemove', e => { if(this.isDown) this.input(e); });
            cvs.addEventListener('mouseup', () => this.isDown=false);
            
            // Gambar awal
            this.draw();
        },

        reset: function() {
            const m = State.map;
            // Isi ulang grid dengan 0 (kosong)
            m.grid = Array(m.cols).fill(0).map(() => Array(m.rows).fill(0));
            State.path = [];
			State.trail = [];
            
            // Reset posisi robot ke Start
            State.obj.robot.x = State.obj.start.x * m.size + m.size/2;
            State.obj.robot.y = State.obj.start.y * m.size + m.size/2;
            State.obj.robot.th = 0;
            
            this.draw();
        },

        setMode: function(m) { 
            this.mode = m; 
            // Update visual tombol aktif (opsional/sederhana)
            document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('btn-active'));
            document.getElementById('t-'+m).classList.add('btn-active');
        },

        // Mengubah koordinat Mouse menjadi Koordinat Grid
        input: function(e) {
            const rect = document.getElementById('simCanvas').getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / State.map.size);
            const y = Math.floor((e.clientY - rect.top) / State.map.size);

            // Cek batas array
            if(x < 0 || x >= State.map.cols || y < 0 || y >= State.map.rows) return;

            // Eksekusi sesuai mode
            if(this.mode === 'wall') State.map.grid[x][y] = 1;
            else if(this.mode === 'eraser') State.map.grid[x][y] = 0;
            else if(this.mode === 'start') { State.obj.start = {x, y}; this.resetRobotToStart(); }
            else if(this.mode === 'goal') { State.obj.goal = {x, y}; }

            // Hitung ulang jalur otomatis (Auto-Replan)
            GLOBAL.plan();
            this.draw();
        },
        
        resetRobotToStart: function() {
            const m = State.map;
            State.obj.robot.x = State.obj.start.x * m.size + m.size/2;
            State.obj.robot.y = State.obj.start.y * m.size + m.size/2;
        },

        draw: function() {
            const ctx = document.getElementById('simCanvas').getContext('2d');
            const m = State.map;
            const cs = m.size;

            // 1. Clear Background
            ctx.fillStyle = "#050505";
            ctx.fillRect(0, 0, m.width, m.height);

            // 2. Draw Grid & Walls
            for(let x=0; x<m.cols; x++) {
                for(let y=0; y<m.rows; y++) {
                    // Garis Grid Tipis
                    ctx.strokeStyle = "#1e293b"; 
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x*cs, y*cs, cs, cs);

                    // Tembok
                    if(m.grid[x][y] === 1) {
                        ctx.fillStyle = "#334155";
                        ctx.fillRect(x*cs, y*cs, cs, cs);
                        ctx.strokeStyle = "#475569";
                        ctx.strokeRect(x*cs, y*cs, cs, cs);
                    }
                }
            }

            // 3. Draw Global Path (Garis Hijau)
            if(State.path.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = "#10b981"; // Emerald
                ctx.lineWidth = 2;
                State.path.forEach((p, i) => {
                    const px = p.x * cs + cs/2;
                    const py = p.y * cs + cs/2;
                    if(i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                ctx.stroke();
            }

            // 4. Draw Start & Goal
            this.drawIcon(ctx, "S", State.obj.start, "#10b981");
            this.drawIcon(ctx, "G", State.obj.goal, "#f43f5e");
        },

        drawIcon: function(ctx, txt, pos, color) {
            const cs = State.map.size;
            const cx = pos.x * cs + cs/2;
            const cy = pos.y * cs + cs/2;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, cs/3, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle = "white"; 
            ctx.font = "bold 10px Arial"; 
            ctx.textAlign="center"; ctx.textBaseline="middle";
            ctx.fillText(txt, cx, cy);
        }
    };

    // --- GLOBAL PLANNER (Algoritma A* & Dijkstra) ---
    const GLOBAL = {
        plan: function() {
            const mode = document.getElementById('global-algo').value;
            
            // Jika mode manual, kosongkan path
            if (mode === 'none') { State.path = []; return; }

            const start = State.obj.start;
            const goal = State.obj.goal;
            const grid = State.map.grid;

            // Struktur Data A*
            let openSet = [start];
            let cameFrom = {}; // Untuk melacak jalur balik
            let gScore = {};   // Biaya dari start ke node ini
            
            // Helper ID unik untuk koordinat "x,y"
            const id = p => `${p.x},${p.y}`;

            gScore[id(start)] = 0;
            
            let fScore = {}; // Estimasi Total Biaya (G + Heuristic)
            fScore[id(start)] = (mode === 'astar') ? this.heuristic(start, goal) : 0;

            while(openSet.length > 0) {
                // Ambil node dengan fScore terendah
                let current = openSet.reduce((a, b) => 
                    (fScore[id(a)]||Infinity) < (fScore[id(b)]||Infinity) ? a : b
                );

                // Cek Sampai Tujuan
                if(current.x === goal.x && current.y === goal.y) {
                    this.reconstruct(cameFrom, current);
                    return;
                }

                // Hapus current dari openSet
                openSet = openSet.filter(n => id(n) !== id(current));

                // Cek Tetangga (Atas, Bawah, Kiri, Kanan)
                const neighbors = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                
                for(let n of neighbors) {
                    let next = {x: current.x + n.x, y: current.y + n.y};

                    // Cek Batas Peta & Tembok
                    if(next.x < 0 || next.x >= State.map.cols || 
                       next.y < 0 || next.y >= State.map.rows) continue;
                    if(grid[next.x][next.y] === 1) continue; // Nabrak tembok

                    // Biaya langkah = 1
                    let tentativeG = (gScore[id(current)]||Infinity) + 1;

                    if(tentativeG < (gScore[id(next)]||Infinity)) {
                        // Jalur ini lebih baik! Simpan.
                        cameFrom[id(next)] = current;
                        gScore[id(next)] = tentativeG;
                        
                        // Dijkstra: Heuristic = 0
                        // A*: Heuristic = Jarak Manhattan
                        let h = (mode === 'astar') ? this.heuristic(next, goal) : 0;
                        fScore[id(next)] = tentativeG + h;

                        if(!openSet.some(x => id(x) === id(next))) {
                            openSet.push(next);
                        }
                    }
                }
            }

            // Jika loop selesai tanpa return, berarti tidak ada jalan
            State.path = [];
            UI.log("Global Planner: No Path Found!");
        },

        // Heuristik Jarak Manhattan (Lurus kotak-kotak)
        heuristic: function(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        },

        // Rekonstruksi jalur dari Goal mundur ke Start
        reconstruct: function(cameFrom, current) {
            const id = p => `${p.x},${p.y}`;
            let totalPath = [current];
            while(id(current) in cameFrom) {
                current = cameFrom[id(current)];
                totalPath.unshift(current);
            }
            State.path = totalPath;
            UI.log(`Global Path: Found (${totalPath.length} steps)`);
        }
    };
	
	/** ==========================================
     * BAGIAN 3: ROBOT PHYSICS & LOCAL PLANNER
     * ==========================================
     */

    const ROBOT = {
        // --- 1. PHYSICS UPDATE ---
        update: function(dt) {
            const r = State.obj.robot;
            
            // Integrasi Euler
            r.th += r.w * dt;
            while(r.th > Math.PI) r.th -= 2 * Math.PI;
            while(r.th < -Math.PI) r.th += 2 * Math.PI;

            r.x += r.v * Math.cos(r.th) * dt;
            r.y += r.v * Math.sin(r.th) * dt;

            this.checkCollision();

            // [BARU] Rekam Jejak (Trajectory)
            // Hanya rekam jika robot bergerak
            if (Math.abs(r.v) > 0.1) {
                // Push posisi saat ini ke array trail
                State.trail.push({x: r.x, y: r.y});
                
                // Batasi panjang jejak agar memori tidak penuh (opsional, misal max 2000 titik)
                if(State.trail.length > 2000) State.trail.shift();
            }
        },

        checkCollision: function() { /* ... (Kode lama tetap sama) ... */
            const r = State.obj.robot, m = State.map;
            if(r.x < 0 || r.x > m.width || r.y < 0 || r.y > m.height) { r.v = 0; return; }
            const gx = Math.floor(r.x / m.size), gy = Math.floor(r.y / m.size);
            if(gx >= 0 && gx < m.cols && gy >= 0 && gy < m.rows) {
                if(m.grid[gx][gy] === 1) {
                    r.v = 0; r.x -= Math.cos(r.th) * 2; r.y -= Math.sin(r.th) * 2;
                }
            }
        },

        draw: function() {
            const ctx = document.getElementById('simCanvas').getContext('2d');
            const r = State.obj.robot;
            const size = Params.robot.radius;
            
            // [BARU] Gambar Jejak Lintasan (Garis Merah Tipis)
            if (State.trail.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = "rgba(244, 63, 94, 0.6)"; // Rose color transparan
                ctx.lineWidth = 1; // Garis tipis
                ctx.moveTo(State.trail[0].x, State.trail[0].y);
                for (let i = 1; i < State.trail.length; i++) {
                    ctx.lineTo(State.trail[i].x, State.trail[i].y);
                }
                ctx.stroke();
            }

            // Gambar Robot (Kode lama)
            ctx.save(); ctx.translate(r.x, r.y); ctx.rotate(r.th);
            ctx.beginPath(); ctx.moveTo(size + 2, 0); ctx.lineTo(-size, size - 2); ctx.lineTo(-size, -size + 2); ctx.closePath();
            ctx.fillStyle = "#38bdf8"; ctx.shadowColor = "#0ea5e9"; ctx.shadowBlur = 10; ctx.fill();
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(size,0); ctx.strokeStyle="white"; ctx.lineWidth=1.5; ctx.stroke();
            ctx.restore();

            // [UPDATE] Tampilkan posisi dalam METER
            // Rumus: (Pixel / PPM)
            const posX_m = (r.x / Params.ppm).toFixed(2);
            const posY_m = ((State.map.height - r.y) / Params.ppm).toFixed(2); // Invert Y agar 0 di bawah
            
            document.getElementById('debug-pos').innerText = 
                `X:${posX_m}m Y:${posY_m}m Î¸:${(r.th*57.3).toFixed(0)}Â°`;
        }
    };

    // --- 2. LOCAL PLANNER & CONTROL LOGIC ---
    const PLANNER = {
        computeCommand: function() {
            const mode = document.getElementById('control-mode').value;
            // Hitung kecepatan pixel per detik
            // speedPixel = speedMeter * PPM
            const maxSpeedPx = Params.robot.maxSpeed * Params.ppm; 
            
            if (mode === 'pid') {
                return this.runPID(maxSpeedPx);
            } else {
                return this.runAPF(maxSpeedPx);
            }
        },

        // Terima parameter maxSpeedPx
        runPID: function(maxSpeedPx) {
            const path = State.path, r = State.obj.robot, cs = State.map.size;
            if(!path || path.length === 0) return {v: 0, w: 0};

            let targetIdx = 0, minDist = Infinity;
            for(let i=0; i<path.length; i++) {
                const d = Math.hypot((path[i].x * cs + cs/2) - r.x, (path[i].y * cs + cs/2) - r.y);
                if(d < minDist) { minDist = d; targetIdx = i; }
            }

            let lookStep = Math.ceil(Params.pid.lookAhead / cs); 
            let finalIdx = Math.min(targetIdx + lookStep, path.length - 1);
            const tx = path[finalIdx].x * cs + cs/2, ty = path[finalIdx].y * cs + cs/2;

            if(Math.hypot(tx - r.x, ty - r.y) < 15 && finalIdx === path.length - 1) {
                UI.log("PID: Arrived at Goal!"); return {v: 0, w: 0};
            }

            let errTh = Math.atan2(ty - r.y, tx - r.x) - r.th;
            while(errTh > Math.PI) errTh -= 2 * Math.PI;
            while(errTh < -Math.PI) errTh += 2 * Math.PI;

            const w = Params.pid.kp * errTh;
            
            // Gunakan maxSpeedPx
            let v = maxSpeedPx; 
            if(Math.abs(errTh) > 0.5) v *= 0.5;

            UI.log(`PID: Tracking Index ${finalIdx}`);
            return { v: v, w: w };
        },

        runAPF: function(maxSpeedPx) {
            // ... (Kode APF Awal sama) ...
            const r = State.obj.robot, goal = State.obj.goal, cs = State.map.size, p = Params.apf;
            const gx = goal.x * cs + cs/2, gy = goal.y * cs + cs/2;
            const dx = gx - r.x, dy = gy - r.y, distGoal = Math.hypot(dx, dy);

            if(distGoal < 15) { UI.log("APF: Arrived at Goal!"); return {v: 0, w: 0}; }

            let fx = (dx / distGoal) * p.k_att, fy = (dy / distGoal) * p.k_att;
            const range = Math.ceil(p.distLimit / cs), rx = Math.floor(r.x / cs), ry = Math.floor(r.y / cs);

            // ... (Loop Tembok sama persis, copy paste saja bagian loop for tembok dari kode lama) ...
            for(let x = rx - range; x <= rx + range; x++) {
                for(let y = ry - range; y <= ry + range; y++) {
                    if(x < 0 || x >= State.map.cols || y < 0 || y >= State.map.rows) continue;
                    if(State.map.grid[x][y] === 1) {
                        const wx = x * cs + cs/2, wy = y * cs + cs/2;
                        const distWall = Math.hypot(r.x - wx, r.y - wy);
                        if(distWall < p.distLimit && distWall > 0) {
                            const repFactor = p.k_rep * (1.0/distWall - 1.0/p.distLimit) / (distWall * distWall);
                            fx += (r.x - wx) * repFactor * 1000; fy += (r.y - wy) * repFactor * 1000;
                        }
                    }
                }
            }

            let errTh = Math.atan2(fy, fx) - r.th;
            while(errTh > Math.PI) errTh -= 2 * Math.PI;
            while(errTh < -Math.PI) errTh += 2 * Math.PI;

            const w = 5.0 * errTh; 
            
            // Update Speed Calculation menggunakan maxSpeedPx
            const totalForce = Math.hypot(fx, fy);
            let v = Math.min(totalForce * 10, maxSpeedPx);
            
            if(Math.abs(errTh) > Math.PI/2) v = 0;

            UI.log(`APF: Force [${fx.toFixed(1)}, ${fy.toFixed(1)}]`);
            return { v: v, w: w };
        }
    };
	
	/** ==========================================
     * BAGIAN 4: MAIN LOOP & INTEGRATION
     * ==========================================
     */

    const SIM_CORE = {
        lastTime: 0,
        animationId: null,

        toggle: function() {
            State.running = !State.running;
            const btn = document.getElementById('btn-run');
            if(State.running) {
                // [BARU] Reset Trail saat Start baru
                if(State.path.length === 0) GLOBAL.plan();
                
                // Jangan hapus trail jika Pause->Resume, tapi hapus jika Reset map
                
                btn.innerHTML = "â¸ PAUSE SIM";
                btn.classList.replace('bg-emerald-600', 'bg-amber-600');
                btn.classList.replace('border-emerald-500', 'border-amber-500');
                
                this.lastTime = performance.now();
                this.loop(performance.now());
            } else {
                btn.innerHTML = "â–¶ START SIM";
                btn.classList.replace('bg-amber-600', 'bg-emerald-600');
                btn.classList.replace('border-amber-500', 'border-emerald-500');
                cancelAnimationFrame(this.animationId);
            }
        },

        loop: function(timestamp) {
            if(!State.running) return;
            let dt = (timestamp - this.lastTime) / 1000;
            if(dt > 0.1) dt = 0.1;
            this.lastTime = timestamp;

            // [BARU] Terapkan Simulation Speed (Time Scale)
            const scaledDt = dt * State.timeScale;
            
            // Simpan ke State (opsional, untuk debug)
            State.dt = scaledDt;

            const cmd = PLANNER.computeCommand();
            State.obj.robot.v = cmd.v;
            State.obj.robot.w = cmd.w;

            // Gunakan scaledDt untuk update fisika
            ROBOT.update(scaledDt);
            
            MAP.draw();     
            ROBOT.draw();

            this.animationId = requestAnimationFrame(t => this.loop(t));
        }
    };

    // Jalankan Init Map saat script dimuat
    MAP.init();

</script>
</body>
</html>